import flat from "flat";
const { flatten, unflatten } = flat;
export default class Openrouteservice {
    apiKey;
    constructor(apiKey) {
        this.apiKey = apiKey;
    }
    orsFetch = (endpoint, post, body) => fetch(`https://api.openrouteservice.org${endpoint}${post ? '' : `?api_key=${this.apiKey}&${body}`}`, post ? {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
            'Authorization': this.apiKey
        },
        body
    } : {}).then(async (res) => {
        const text = await res.text();
        try {
            return JSON.parse(text);
        }
        catch (e) {
            return text;
        }
    });
    getBasicDirections = async (profile, start, end) => this.orsFetch('/v2/directions/' + profile, false, new URLSearchParams({
        start: start.join(','),
        end: end.join(',')
    }).toString());
    async getDirections(profile, format, query) {
        return this.orsFetch(`/v2/directions/${profile}/${format}`, true, JSON.stringify(query));
    }
    getIsochrones = async (profile, query) => this.orsFetch('/v2/isochrones/' + profile, true, JSON.stringify(query));
    getMatrix = async (profile, query) => this.orsFetch('/v2/matrix/' + profile, true, JSON.stringify(query));
    static unflattenResult(res) {
        res.geocoding.query = unflatten(res.geocoding.query);
        return res;
    }
    async getGeocodeSearch(query, additionalQuery) {
        const structured = typeof query !== 'string';
        const params = flatten({
            ...(structured ? query : {}),
            ...(additionalQuery ?? {})
        });
        if (!structured)
            params.text = query;
        if (additionalQuery?.sources)
            params.sources = additionalQuery.sources.join(',');
        if (additionalQuery?.layers)
            params.layers = additionalQuery.layers.join(',');
        return this.orsFetch('/geocode/search' + (structured ? '/structured' : ''), false, new URLSearchParams(params).toString()).then(Openrouteservice.unflattenResult);
    }
    async getGeocodeAutocomplete(text, query) {
        const params = flatten(query ?? {});
        params.text = text;
        if (query?.sources)
            params.sources = query.sources.join(',');
        if (query?.layers)
            params.layers = query.layers.join(',');
        return this.orsFetch('/geocode/autocomplete', false, new URLSearchParams(params).toString()).then(Openrouteservice.unflattenResult);
    }
    async getGeocodeReverse(query) {
        const params = flatten(query);
        if (query.sources)
            params.sources = query.sources.join(',');
        if (query.layers)
            params.layers = query.layers.join(',');
        return this.orsFetch('/geocode/reverse', false, new URLSearchParams(params).toString()).then(Openrouteservice.unflattenResult);
    }
    async getPOIs(query) {
        return this.orsFetch('/pois', true, JSON.stringify(query));
    }
    async getElevation(geometry, outputFormat) {
        const isPoint = (typeof geometry === 'object'
            &&
                !Array.isArray(geometry)
            &&
                geometry.type === 'Point') || (Array.isArray(geometry)
            &&
                typeof geometry[0] === 'number');
        const isGeoJSON = typeof geometry === 'object' && 'type' in geometry;
        const isEncodedPolyline = typeof geometry === 'string';
        const endpoint = `/elevation/${isPoint ? 'point' : 'line'}`;
        const params = (isPoint && !isGeoJSON)
            ? new URLSearchParams({
                geometry: geometry.join(','),
                format_out: outputFormat
            }).toString() : JSON.stringify({
            format_in: (isEncodedPolyline
                ? 'encodedpolyline5'
                : isGeoJSON
                    ? 'geojson'
                    : isPoint
                        ? 'point'
                        : 'polyline'), geometry
        });
        return this.orsFetch(endpoint, !(isPoint && !isGeoJSON), params);
    }
    // async getOptimization(query: OptimizationQuery) {
    //     return this.orsFetch(
    //         '/optimization',
    //         true,
    //         JSON.stringify(query)
    //     )
    // }
    static decodePolyline(encodedPolyline, includeElevation) {
        const points = [];
        let index = 0;
        let lat = 0;
        let lng = 0;
        let ele = 0;
        while (index < encodedPolyline.length) {
            let b;
            let shift = 0;
            let result = 0;
            do {
                b = encodedPolyline.charAt(index++).charCodeAt(0) - 63;
                result |= (b & 0x1f) << shift;
                shift += 5;
            } while (b >= 0x20);
            lat += ((result & 1) !== 0 ? ~(result >> 1) : (result >> 1));
            shift = 0;
            result = 0;
            do {
                b = encodedPolyline.charAt(index++).charCodeAt(0) - 63;
                result |= (b & 0x1f) << shift;
                shift += 5;
            } while (b >= 0x20);
            lng += ((result & 1) !== 0 ? ~(result >> 1) : (result >> 1));
            if (includeElevation) {
                shift = 0;
                result = 0;
                do {
                    b = encodedPolyline.charAt(index++).charCodeAt(0) - 63;
                    result |= (b & 0x1f) << shift;
                    shift += 5;
                } while (b >= 0x20);
                ele += ((result & 1) !== 0 ? ~(result >> 1) : (result >> 1));
            }
            try {
                let location = [(lng / 1E5), (lat / 1E5)];
                if (includeElevation)
                    location.push((ele / 100));
                points.push(location);
            }
            catch (e) {
                console.log(e);
            }
        }
        return points;
    }
}
